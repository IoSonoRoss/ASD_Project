generaGridMap(larghezza, altezza):
    """
    Crea una gridMap di dimensioni specificate.

    Args:
        larghezza: Larghezza della gridMap.
        altezza: Altezza della gridMap.

    Returns:
        Una matrice che rappresenta la gridMap.
    """
    return [[0 for _ in range(larghezza)] for _ in range(altezza)]

generaMuri(gridMap):
    """
    Genera muri casuali in una gridMap.

    Args:
        gridMap: La matrice della gridMap da modificare.

    Returns:
        La gridMap con muri aggiunti.
    """

    altezza = len(gridMap)
    larghezza = len(gridMap[0])

    for i in range(altezza):
        for j in range(larghezza):
            if random.random() < 0.2:  # 20% di probabilità di essere un muro <--- si può modificare
                gridMap[i][j] = 1  # 1 rappresenta un muro

    return gridMap

isAdiacente(x1, y1, x2, y2):
    """
    Verifica se due celle sono adiacenti in una gridMap (inclusi movimenti diagonali)

    Args:
        x1, y1: Coordinate della prima cella.
        x2, y2: Coordinate della seconda cella.

    Returns:
        True se le celle sono adiacenti, False altrimenti.
    """
    if x1 == x2 and y1 == y2:
        return False  # Una cella non è adiacente a se stessa

    if abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1:
        return True

    return False

isMuro(gridMap, x, y):
    """
    Verifica se una cella è un muro.

    Args:
        gridMap: La matrice della gridMap.
        x, y: Coordinate della cella da verificare.

    Returns:
        True se la cella è un muro, False altrimenti.
    """
    if 0 <= x < len(gridMap[0]) and 0 <= y < len(gridMap):
        return gridMap[y][x] == 1
    return False


mossa(gridMap, x, y, direzione):
    """
    Calcola la nuova posizione dopo una mossa cardinale o diagonale, verificando che sia valida.

    Args:
        gridMap: La matrice della gridMap.
        x, y: Coordinate attuali.
        direzione: Mossa da effettuare ('N', 'S', 'E', 'O', 'NE', 'NO', 'SE', 'SO').

    Returns:
        Tuple con le nuove coordinate (x, y) se la mossa è valida,
        altrimenti una stringa di errore preimpostata.
    """
    if direzione == 'N':
        nx = x
        ny = y - 1
    elif direzione == 'S':
        nx = x
        ny = y + 1
    elif direzione == 'E':
        nx = x + 1
        ny = y
    elif direzione == 'O':
        nx = x - 1
        ny = y
    elif direzione == 'NE':
        nx = x + 1
        ny = y - 1
    elif direzione == 'NO':
        nx = x - 1
        ny = y - 1
    elif direzione == 'SE':
        nx = x + 1
        ny = y + 1
    elif direzione == 'SO':
        nx = x - 1
        ny = y + 1
    else:
        return "Errore: mossa non valida. Usa 'N', 'S', 'E', 'O', 'NE', 'NO', 'SE' o 'SO'."

    larghezza = len(gridMap[0])
    altezza = len(gridMap)

    if not isDentroGridMap(gridMap, nx, ny):
        return "Errore: mossa fuori dai limiti della gridMap."

    if isMuro(gridMap, nx, ny):
        return "Errore: la cella di destinazione è un muro."

    return (nx, ny)

isDentroGridMap(gridMap, x, y):
    """
    Verifica se le coordinate sono all'interno della gridMap.

    Args:
        gridMap: La matrice della gridMap.
        x, y: Coordinate da verificare.

    Returns:
        True se le coordinate sono valide, False altrimenti.
    """
    return 0 <= x < len(gridMap[0]) and 0 <= y < len(gridMap)

calcolaDistanzaMossa(direzione):
    """
    Calcola la distanza della mossa in base alla direzione.

    Args:
        direzione: Mossa da effettuare ('N', 'S', 'E', 'O', 'NE', 'NO', 'SE', 'SO').

    Returns:
        La distanza della mossa (1 per movimenti cardinali, sqrt(2) per diagonali).
    """
    if direzione in ['N', 'S', 'E', 'O']:
        return 1
    elif direzione in ['NE', 'NO', 'SE', 'SO']:
        return sqrt(2)
    else:
        return 0  # Mossa non valida

# Generatore con altri parametri personalizzabili ancora da introdurre

# Anche il cammino è da introdurre?